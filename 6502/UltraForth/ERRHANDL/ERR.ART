ERR.ART
Korrektur clv03jul89
Entwurf   clv01mar88

set margins 1 40
(mit c-t in Kommandozeile)


Titel:

Behandlung von Ausnahmesituationen in
Forth83

Stichworte:

Fehlerbehandlung
Ausnahmebehandlung
exception handling
volksFORTH83
returnstack

Kurzfassung:
Ausgehend von einer Analyse
des BedÅrfnisses nach
programmspezifische Fehlerbehandlung
(die insbesondere zum erweiterten
Begriff des 'Exception handling' fÅhrt)
werden Konzepte aus verschiedenen Programmiersprachen
sowie zu Forth83 vorgeschlagene Konzepte
auf ihre Brauchbarkeit
hin diskutiert. Es folgt eine unter
ultraFORTH83 rev 3.8 auf einem C16
entwickelte
Lîsung des Autors, die abhÑngig von
der AusfÅhrungsebene eine spezielle
mittels FAILS..THEN installierte
Behandlung der Worte ABORT" und ERROR"
gestattet.

o Die derzeitige Fehlerbehandlung
  in Forth: ABORT"

Im 83er-Standard ist das zentrale Wort
zur Fehlerbehandlung ABORT". Es
gibt den folgenden String als
Fehlernachricht aus, versetzt das System
in einen (einigerma·en) definierten
Zustand und ruft das Top-Level-Wort QUIT
auf, das Eingaben von der Tastatur
entgegennimmt und verarbeitet.
Jedes laufende Programm wird also ohne
RÅcksicht auf Verluste gestoppt und
gewisserma·en Forth neu gestartet.
Eine Ñhnliche Wirkung haben die Worte
ABORT und QUIT.

Im ultraFORTH83/volksFORTH83 gibt es
ein Wort ERROR", das sich von ABORT" nur
dadurch unterscheidet, da· der
Datenstack nicht gelîscht wird.
Desweiteren enthÑlt dieses Forth eine
User-Variable ERRORHANDLER, die es
ermîglicht, ein anderes Verhalten von
ABORT" und ERROR" zu installieren.


o Was soll eine Fehlerbehandlung
  kînnen

Diese Art der
Fehlerbehandlung
funktioniert zwar meistens recht gut,
wirft aber einige Probleme auf.
Im folgenden wird versucht, folgende
Stichworte zu diskutieren:

    - Reservierte  Ressourcen
      schlie·en
    - Das Level, auf dem die Behandlung
      erfolgt
    - Informationen Åber den
      Fehlerzustand erhalten.
    - öbersichtliche Behandlung
      selten auftretender Ereignisse
    - Fehler auch wÑhrend der
      Fehlerbehandlung (ohne
      Endlosschleifen)

Hierbei flie·en jeweils die Erfahrungen
des Autors mit MS-DOS, Pascal,
Modula-2, Fortran und TLC-Lisp mit ein.

o Schlie·en von Ressourcen

Das Wort ABORT" (so es im Quelltext
vorliegt) zeigt bereits da· im
Fehlerfalle gewisse Systemressourcen
wieder freigegeben werden mÅssen.
Zumindest dÅrfte in jedem System der
Return-stack entleert werden, oft auch
der Datenstack, vielleicht werden
sogar gewisse Systemvektoren restauriert
(insb. fÅr die Standard-Ein/Ausgabe
scheint das geraten).
Falls das Programm gewisse
weitere Ressourcen
reserviert hat, werden sie nicht wieder
frei gegeben. Dies kînnte ein geîffnetes
File sein, das nicht geschlossen wird;
ein Semaphor, das gelockt bleibt; ein
menÅartiger Bildschirm, der weiter in
allen Farben des Spektrums blinkt; eine
hoffnungslos verdrehte Schnittstelle
etc.. Am auffÑlligsten ist eine z.B. auf
den Drucker umgeleitete Standardausgabe,
wenn sie von ABORT" nicht restauriert
wird.
In diesem Fall wird schon die Ausgabe
der ABORT"-Meldung (auf den Drucker)
fehlschlagen, insb. wenn die gewÅnschte
Fehlermeldung "Drucker ausgeschaltet"
hei·en mag. Dieser Effekt wird in jedem
intelligenten Forth-System natÅrlich
abgefangen, unter MS-DOS lÑ·t er
sich allerdings noch sehr hÅbsch
beobachten. Die gelockten Semaphore
machen sich allerdings - in seltenen
FÑllen - auch unter volksFORTH
bemerkbar. Vîllig hoffnungslos wird der
Fall, wenn eine grî·ere
Stand-Alone-Anwendung (z.B. ein
fÅrchterlich kompliziertes MenÅprogramm)
grade sÑmtliche Systemvektoren
erfolgreich verbogen hat und nun durch
einem jÑmmerlich kleinen Fehler
(vielleicht einen offengelassener
Diskettenschacht) jÑh in die
Forth-Hauptschleife geschleudert wird.

o Auf welcher Programmebene soll der
  Fehler behandelt werden?

In einem Fall
wie letzterem wÑre es sogar denkbar,
den Fehler noch innerhalb der
Systemroutinem (in diesem Fall in der
Block-Lese-Routine des Betriebssystem)
zu beseitigen
(z.B. den Benutzer aufzufordern, doch
bitte den Schacht zu schlie·en) und
anschlie·end fortzufahren, ohne da·
das darÅberliegende Programm etwas
bemerkt. Derartiges kann sogar MS-DOS.
Alle Fehler die
in Zusammenhang mit Diskettenlaufwerkern
stehen werden noch innerhalb des
Betriebssystems mit einer Meldung der
Form:

allgemeiner Fehler. Kaffee in Laufwerk A:
(A)bbruch, (W)iederholen, (I)gnorieren ?

beantwortet. Der Benutzer kann sich nun
fÅr eine der Alternativen entscheiden.
Tippt er 'W', so versucht das System
denselben Zugriff nochmal. Dies ist bei
einem offen gelassenen Schacht nÅtzlich,
gegen Kaffee hilft es natÅrlich nicht.
'A' terminiert das laufende Programm und
springt zurÅck ins Betriebssystem (in
etwa wie unser QUIT). Dies funktioniert
meistens, es sei denn das Betriebssystem
mîchte selbst Teile seiner selbst von
der Diskette lesen: Wir bekommen die
beliebte Endlosschleife, bis wir eine
saubere Diskette eingelegt haben.
Die Alternative 'I' ist die hÅbscheste.
Das System vergi·t die Operation und
kehrt ins rufende Programm zurÅck.
Dieses arbeitet brav weiter, bis es
sich an irgendwelchenden Zufallsergebnissen
den Magen verdirbt. Um zum Beispiel
des MenÅ-Programms mit offenen
Kassettenschacht noch ein Wort zu
verlieren: Beim 'W'iederholen ist
natÅrlich trotz allem der
Bildschirmaufbau im Eimer. Bis hierher
lÑ·t sich erstmal formulieren, da·
die Fehlerbehandlung lieber auf der
Ebene des Anwenderprogramms erfolgen
sollte.

o Warum eigentlich nur Fehler mit
  Methoden der Fehlerbehandlung
  behandeln?

Um diesem hÅbschen Wortspiel Sinn zu
geben, mag ein anderes Beispiel
herhalten.
Ein Programm lese
Daten von einem File, verarbeite sie und
schreibe das Ergebnis auf ein anderes
File.
Es mu· somit (wenn es strukturiert sein
mîchte) vor dem Lesen jedes einzelnen
Zeichens das Betriebssystem befragen, ob
das File vielleicht schon erschîpft ist.
Das ergibt beispielsweise in Pascal
endlose Konstrukte des Strickmusters:

   WHILE not eof(input) DO
   WHILE not eoLn(input) DO
   BEGIN
      READ (input,char);
      IF char=...THEN
	 ....
	 IF or(eof(input),eoLn(input)
	 THEN schweinkram;
	 ELSE  read (input,nochn_char);
	       ....
	 ENDIF;
	 ....
      ENDIF;
   END;

Man verzeihe es mir, wenn ich die
Pascal-Syntax nicht mehr so besonders
gut kann. Das Strickmuster sollte
eigentlich etwas anderes zeigen: In
Pascal erfordert jeder Zugriff eines
Programms (so es sich strukturiert nenn
will) das Abfragen auf End-Of-File und
End-Of-Line. Letzteres ist nîtig, da der
Standard leider (?) nicht vorschreibt,
wie EOLn am Fileende aussieht. Soll
innerhalb der gro·en WHILE-Schleife ein
weiteres Zeichen gelesen werden, so mu·
beides erneut geprÅft werden, da· System
Ñrgert sich mit stÑndigem Abgefrage
herum, der Programmierer mit der
Definition der Routine 'schweinkram',
die ihren Namen i.a. zu Recht trÑgt.

Viel einfacher haben es da Sprachen, die
keinerlei Anspruch auf strukturiertes
Programmieren erheben. Das obige
Kuddelmuddel lie·e sich in Fortran etwa
so umgehen:

  10  READ (input,char,end=100,err=200)
      IF char.eq..... THEN
	 READ (input,nochnchar,err=200)
      ENDIF
      GOTO 10
      ...
 100  ...<fileEnde behandeln>...
 200  ...<sonstige Fehler behandeln>...

Die 'end=' und 'err=' Sequenzen sind
verkappte GOTOs.
Hier wird (vîllig unstrukturiert) der
Programmflu· im Fehlerfall unterbrochen
und an den durch 100 und 200
gekennzeichneten Stellen fortgesetzt.
Ein Ñhnliches GOTO-Konstrukt bietet auch
Pascal an. Jedes gute Lehrbuch bittet
aber darum es mîglichst nie zu benutzen.
Als einzigen tolerierbaren Zweck wird
meist die Fehlerbehandlung angegeben.
Ein sehr treffender Beleg dafÅr, da·
grade dem Vater der strukturierten
Programmierung, Herrn Wirth, die
Fehlerbehandlung Kopfzerbrechen
bereitet.

Was sollte das nun belegen? Es soll
zeigen, da· erstens auch vîllig
normale VorgÑnge (Ende eines Files)
fehlerbehandelt werden wollen. In diesem
Fall spricht man von
'Ausnahmebehandlung', da dieser
Programmierstil nur fÅr selten
auftretende FÑlle sinnvoll ist. Es soll
zweitens zeigen, da· eine Erhîhung der
Performance und Wartbarkeit aus
sinnvoller Ausnahmebehandlung
entspringt. Denn sicher spart das obige
Fortran-beispiel einigen Code. Dies
spart auch Zeit, da an weniger
Stellen auf Fehler geprÅft
werden mu·. Und ich kann es besser
lesen. (Zur Frage der Lesbarkeit steht
mir als Nicht-Informatiker kein
allgemeines Urteil zu. Die
'ich'-Form spart mir hier sicher wieder
einigen Streit mit Helge und Gerd.)

o Ist Ausnahmebehandlung
  auf ganz tiefer Ebene verzichtbar ?

Manchmal mu· aber auch eine
Ausnahmebehandlung auf ganz tiefer
Ebene erfolgen. Als Beispiel sei hier
die Ausgabe von Informationen im
Fehlerfall genannt. HÑufig mîchte der
Benutzer im Fehlerfall wissen, wo der
Fehler aufgetreten ist, wie bestimmte
Variablen aussahen, etc.
Im volksFORTH gibt es ein Wort
UNRAVEL, das die Aufrufhierarchie
ausgibt.
Dies kînnte etwa so aussehen:

FEHLER divide by Zero AUFGETRETEN.
   Der Fehler geschah in Wort: 0/
	       aufgerufen von: MEINWORT
	       aufgerufen von: TEST
	       aufgerufen von: EDIT
	       aufgerufen von: L

Derartige POST-MORTEM-DUMPS ermîglichen
i.a. ein schnelles Lokalisieren des
Fehlers. Sie enthalten des îfteren nicht
nur die Aufrufhierarchie sondern
diverse Register- und Variablen-Inhalte
zum Zeitpunkt des Fehlers (am besten
noch aus allen Unterprogrammen...),
soda· sie manchmal den Benutzer eher in
hunderten von Seiten Papier ersticken,
als ihm bei der Fehlersuche zu helfen.
Aber selbst dagegen sind KrÑuter
gewachsen. Logitech's Modula-2-Compiler
teilt dem Benutzer au·er einer sehr
knappen Fehlerbeschreibung nichts mit
und schreibt ersatzweise den kompletten
Systemzustand auf Diskette, wo man ihn
anschlie·end mit einem
Post-Mortem-Debug-Programm umgraben
kann. Es frage mich bitte niemand, was
passiert, wenn die Diskette voll war.
Ruft der Fehler dann einen erneuten
Post-Mortem-Dump hervor?

Um wieder zum Faden zurÅckzukehren:
Zumindest zum Post-Mortem-Debuggen
(=Entlausen aus einem toten
Programm. öbertragen: Infos
Åber den Fehlerzustand erhalten)
ist es nîtig Fehler auf niedrigster
Ebene zu behandeln.

o Mein Wunsch zur Fehlerbehandlung:
  Call-with-current-Continuation
  (CallCC)

Die schînste, allgemeinste Art der
Fehlerbehandlung, die ich kenne, ist das
CATCH-THROW-Konstrukt aus TLC-Lisp (von
T.Allen).
Ich habe mir sagen lassen, da· sie unter
Zuhilfenahme des
Call-with-current-Continuation-Konzepts
implementiert ist. Daher gefÑllt mir
dieses auch sehr gut. Da ich CallCC
leider nicht kenne beschrÑnke ich mich
jetzt aber wieder auf CATCH-THROW.
Es wird in folgender Form benutzt:

(CATCH name ((expression)
	     (exceptionhandler)))

Die Bedeutung ist folgende: Wenn wÑhrend
der Evaluierung (=AusfÅhrung auf
LISPisch) von EXPRESSION eine Ausnahme
mit dem Namen NAME auftreten sollte, so
mîge bitte sofort EXCEPTIONHANDLER
evaluiert werden. Ansonsten ist der
obige Ausdruck identisch mit:

   (expression)

Eine Ausnahme tritt dadurch auf, da·
eine Funktion (=wort auf
LISPisch) innerhalb
von expression die Funktion

   (THROW name)

aufruft.

Eigentlich ist es verabscheuungswÅrdig,
von Lisp aus Files zu lesen, da dies dem
funktionalen Programmieren zuwiderlÑuft.
Um aber trotzdem das obige
File-Lese-Beispiel nochmal zu
strapazieren:

(CATCH end-of-file
 (CATCH end-of-line
  (COND
   ((eq (setq char READCHAR))
    (dosomething READCHAR)
   )
   (T
    ( ... )
   )
  )
  ( ...end-of-line-handler..)
 )
 ( ...end-of-file-handler..)
)

Dies sieht nicht nur wundervoll aus mit
den vielen Klammern, sondern hat auch
eine Wirkung: wenn READCHAR irgendwann
(THROW end-of-line) oder (THROW
end-of-file) evaluiert, wird einer
unsrer HANDLER aufgerufen. Ob READCHAR
das tut und ob es in Lisp Åberhaupt eine
Funktion diesen Namens gibt, entzieht
sich leider meiner Kenntnis.
SelbstverstÑndlich kînnen solche handler
geschachtelt werden. Um DOSOMETHING
kînnte z.B. ein noch
spezielleren handler
heruminstalliert werden. Eine AusfÅhrung
von (THROW name) aktiviert jeweils den
nÑchstÑu·eren (hîhergelegenen) handler.
Wenn dieser das nîtige getan hat, kann
er beispielsweise erneut (THROW name)
evaluieren, um wiederum den ihm
nÑchstÑu·eren handler zu aktivieren. Das
Spiel lÑ·t sich weitertreiben, bis
schlie·lich der allerÑu·erste (von der
LISP-Interpreter-Schleife) installierte
handler aufgerufen wird, der (Ñhnlich
unserem ABORT") wieder Eingaben von der
Tastatur verarbeitet. SelbstverstÑndlich
kann jeder handler in der Schlange auch
etwas anderes unternehmen,
beispielsweise die gescheiterte Aktion
wiederholen.

o ZurÅck zu Forth

Aus dem gesagten seien noch einmal die
Kernpunkte zusammengefa·t:
- Fehlerbehandlung soll auf jeder
  beliebigen Programmebene mîchlich sein
- insbesondere auch auf tiefster Ebene
- Die Fehlerbehandlungsroutinen sollen
  geschachtelt werden kînnen
- Fehlerbehandlar sollen Mîglichkeiten
  erhalten, nach Bedarf die
  fehlerverursachende Routine erneut zu
  probieren oder die AusfÅhrung dem
  nÑchsthîheren
  Fehlerbehandler weiterzugeben.
- Das ganze soll so einfach zu benutzen
  sein, da· Routinen fÅr selten
  auftretende Ereignisse einfach zu
  formulieren sind.
- Diese Fehlerbehandlung soll durch das
  Standardwort ABORT" aktiviert werden.

Nun wird's konkret:
Wo sollen die Informationen Åber die
installierten Fehlerbehandlungsroutinen
abgelegt werden? Auf dem Returnstack, da
sich hier am einfachsten eine der
jeweiligen AusfÅhrungsebene (Wort)
angelehnte Datenstruktur bilden lÑ·t.

Wie soll die Syntax aussehen? Es soll
einfach sein, daher Kontrollstrukturen.
Beispielsweise:

: name ..<clause1>..
   FAILS ...errorhandler... THEN
       ..<clause2>.. ;

Die Bedeutung: Es wird ein Wort NAME
definiert. Bei AusfÅhrung fÅhrt NAME
erst <clause1> aus, installiert
anschlie·end einen ERRORHANDLER, fÅhrt
dann <clause2> aus und deinstalliert
ERRORHANDLER nach Verlassen des Wortes.
Sollte innerhalb von <clause2> ein
ABORT" ausgefÅhrt werden, so wird
ERRORHANDLER ausgefÅhrt.

Aktivieren des Ñu·eren ERRORHANDLERS:
Sollte innerhalb von ERRORHANDLER das
Wort THROW ausgefÅhrt werden, so wird
die AusfÅhrung von ERRORHANDLER beendet
und die nÑchstÑu·ere
Fehlerbehandlungsroutine aktiviert.

Wiederholen der fehlerverursachenden
<clause2>: Hier wird's kritisch. Im
Gegensatz zu praktisch allen anderen
Sprachen liegen die Parameter auf dem
Datenstack. Vor einer Wiederholung
mÅssen Daten- und Returnstack repariert
werden. Der Returnstack lÑ·t sich
problemlos so manipulieren, da· er bei
Aufruf von ERRORHANDLER bereits wieder
im gewÅnschten Zustand ist. Falls ein
definierter Zustand des Datenstacks
gewÅmscht wird, mu· allerdings ein
spezielles Konstrukt:

     nn #FAILS ..errorhandler.. RETRY

benutzt werden. Die NN obersten
Stackwerte, sowie der Stackpointer
werden gesichert. Falls ERRORHANDLER
aufgerufen werden sollte, wird der Stack
vorher soweit restauriert. Es gilt
natÅrlich aufzupassen, da· sie bis
zur AusfÅhrung von RETRY auch dableiben.

Noch ein weiteres Konstrukt wurde
eingefÅhrt:

: name ..<clause1>..
   EXITS ..errorhandler.. throw THEN
   ..<clause2>. ;

Es trÑgt der Idee Rechnung, da·
ERRORHANDLER des îfteren nur installiert
wird, um eine Ressource zu schlie·en.
Die Bedeutung: Es wird ein Wort NAME
definiert. Bei AusfÅhrung fÅhrt NAME
erst <clause1> aus, installiert
anschlie·end einen ERRORHANDLER, fÅhrt
dann <clause2> aus. ERRORHANDLER wird
im Falle eines Fehlers oder nach
Verlassen des Wortes NAME ausgefÅhrt.
Es lassen sich also so schîne Konstrukte
bilden wie:

: machWas  ...
   ..<îffne-GerÑt1>..
   EXITS ..<schlie·e-GerÑt1>.. throw THEN
   ..<îffne-GerÑt2>..
   EXITS ..<schlie·e-GerÑt2>.. throw THEN
   .... ;

Es werden auf jeden Fall die geîffneten
GerÑte wieder geschlossen, ob nun ein
Fehler auftritt oder nicht.

o Was gibt es noch fÅr AnsÑtze in Forth

Der vorgestellte Ansatz bringt nichts
prinzipiell neues. In ///////Schliesieck
lÑ·t sich eine Methode nachlesen, die
sicherlich schneller und einfacher
implementiert ist, allerdings verÑndert
sie nicht das Verhalten von ABORT",
sondern mu· mit einem gesonderten Wort
aufgerufen werden. Auch sichert sie
lediglich den Stackpointer, eventuelle
Parameter mÅssen also 'zu Fu·'
gesichert werden. //////weiter....
wenn m

 Schîner: statt THROW ein EXIT
nehmen. Was passiert bei exit?
Bitte nicht IF..ELSE..RETRY
Bitte kein FAILS...THEN ohne throw oder
so

Wie rauskriegen, welcher Fehler passiert ist?
